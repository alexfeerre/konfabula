<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Test Konfabula - Evaluación</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Manrope:wght@400;700&family=Poppins:wght@400;600&display=swap');
    body {
      font-family: 'Poppins', sans-serif;
    }
    h1, h2 {
      font-family: 'Manrope', sans-serif;
    }
  </style>
</head>
<body class="bg-black text-white relative min-h-screen flex flex-col">
  <!-- Header -->
  <header class="flex justify-center items-center gap-8 p-4 border-b border-gray-800">
    <a href="korsakoff.html" class="text-base font-medium hover:underline">Acerca del Korsakoff</a>
    <a href="index.html" class="text-base font-medium hover:underline">Test Konfabula</a>

  </header>

  <!-- Test Section -->
  <main class="flex-1 flex flex-col justify-center items-center text-center px-6 py-12 relative">
   
    <div class="w-full max-w-screen-md">
      <!-- Canvas Container -->
      <div id="canvas-container" class="bg-white w-full h-80 rounded-md mb-8"></div>

      <!-- Buttons -->
      <div class="flex flex-col md:flex-row gap-4 justify-center mb-12">
        <button id="generate-btn" class="px-5 py-2 bg-white text-black rounded-md hover:bg-gray-200 transition text-sm">
          Generar Textura
        </button>
        <button id="download-btn" class="px-5 py-2 bg-white text-black rounded-md hover:bg-gray-200 transition text-sm">
          Descargar Textura
        </button>
      </div>

      <p class="text-lg md:text-xl text-gray-300 mb-8 w-[75%] mx-auto">
        A través de tus respuestas, podrás obtener una evaluación educativa que indique si existen patrones perceptivos asociados con la creación de recuerdos o narrativas falsas, ayudándote a comprender mejor tus procesos cognitivos y su relación con la memoria.
      </p>
      <p class="text-lg md:text-xl text-gray-300 mb-8 w-[75%] mx-auto">
        Nota: Este test no es un diagnóstico médico, sino una herramienta lúdica y reflexiva para el autoconocimiento que debe ir siempre acompañada por la ayuda de un profesional para poder examinar los resultados al momento.      </p>
     
    </div>
     <!-- División antes del Footer -->
     <div class="mt-16 border-t border-gray-700"></div>

     <!-- Footer -->
    
  </main>
  <footer class="bg-gray-50 text-gray-600 py-8">
    <div class="text-center space-y-2 text-xs md:text-sm">
        <p>© 2024 Test Konfabula.</p>
        <p>
            Esta web está diseñada con fines educativos y de divulgación sobre el síndrome de Korsakoff.
        </p>
        <p>
            El contenido no reemplaza el consejo médico profesional.
        </p>
        <p>Todos los derechos reservados.</p>
    </div>
</footer>
  <script>
    const circleButtons = [
      "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+10"
    ];
    const circleContainer = document.getElementById('circle-buttons');
    const nextBtnContainer = document.getElementById('next-btn-container');
    const nextBtn = document.getElementById('next-btn');

    // Generate circle buttons dynamically
    circleButtons.forEach((value) => {
      const button = document.createElement('button');
      button.className = `w-10 h-10 bg-white text-black rounded-full flex items-center justify-center font-medium text-sm hover:bg-gray-300 transition`;
      button.textContent = value;
      button.dataset.value = value; // Store the value for potential use
      button.addEventListener('click', handleCircleClick);
      circleContainer.appendChild(button);
    });

    let selectedButton = null;

    function handleCircleClick(event) {
      const clickedButton = event.currentTarget;

      // Deselect the previously selected button
      if (selectedButton) {
        selectedButton.classList.remove('bg-black', 'text-white');
        selectedButton.classList.add('bg-white', 'text-black');
      }

      // Select the clicked button
      clickedButton.classList.remove('bg-white', 'text-black');
      clickedButton.classList.add('bg-black', 'text-white');

      // Update the selected button reference
      selectedButton = clickedButton;

      // Show the "Next" button
      nextBtnContainer.classList.remove('hidden');
    }

    // Navigate to another HTML when "Next" button is clicked
    nextBtn.addEventListener('click', () => {
      if (selectedButton) {
        // Replace with the desired URL
        window.location.href = "test2.html";
      }
    });
  </script>

  <script>
    let points = [];
    let pos, npos;
    let pg;
    let maxPoints, maxDist, maxSize;
    let isGenerating = false;
    let generationTimer;

    const gridCols = 5;
    const gridRows = 3;
    let cellWidth, cellHeight;
    let pointCountGrid;

    function setup() {
      let canvasContainer = document.getElementById('canvas-container');
      let canvas = createCanvas(canvasContainer.offsetWidth, canvasContainer.offsetHeight);
      canvas.parent('canvas-container');
      pixelDensity(2);

      pg = createGraphics(width, height);
      pg.pixelDensity(2);

      cellWidth = width / gridCols;
      cellHeight = height / gridRows;

      resetParameters();

      document.getElementById('generate-btn').addEventListener('click', startGeneration);
      document.getElementById('download-btn').addEventListener('click', downloadTexture);
    }

    function windowResized() {
      let canvasContainer = document.getElementById('canvas-container');
      resizeCanvas(canvasContainer.offsetWidth, canvasContainer.offsetHeight);
      pg = createGraphics(width, height);
      pg.pixelDensity(2);

      cellWidth = width / gridCols;
      cellHeight = height / gridRows;

      resetParameters();
    }

    function draw() {
      if (!isGenerating) return;

      background(255);
      generateRandom();
      drawSymmetry();

      if (points.length >= maxPoints) {
        console.log("Máximo de puntos alcanzado, pero esperando que se cumpla el tiempo.");
      }
    }

    function resetParameters() {
      background(255);
      pg.clear();
      points = [];
      pos = createVector(width / 2, height / 2);

      maxPoints = floor(1000, 2000);
      maxDist = floor(random(50, 150));
      maxSize = floor(random(width / 60, width / 90));
      pointCountGrid = Array.from({ length: gridRows }, () => Array(gridCols).fill(0));
    }

    function generateRandom() {
      if (points.length < maxPoints) {
        const currentCell = getCell(pos);

        if (pointCountGrid[currentCell.row][currentCell.col] > 50) {
          moveToNewZone();
          return;
        }

        for (let point of points) {
          if (dist(pos.x, pos.y, point.x, point.y) < maxDist) {
            pg.stroke(0, 10);
            pg.line(pos.x, pos.y, point.x, point.y);
            applySymmetryToLine(pos, point);
          }
        }

        applySymmetryToPoint(pos);
        points.push(createVector(pos.x, pos.y));
        pointCountGrid[currentCell.row][currentCell.col]++;

        pos.x += random(-maxSize * 2, maxSize * 2);
        pos.y += random(-maxSize * 2, maxSize * 2);

        if (pos.x < width * 0.05 || pos.x > width * 0.95) pos.x = width / 2;
        if (pos.y < height * 0.05 || pos.y > height * 0.95) pos.y = height / 2;
      }
    }

    function applySymmetryToPoint(point) {
      pg.noStroke();
      pg.fill(0, 30);
      pg.ellipse(point.x, point.y, 5);
      let symPoint = createVector(width - point.x, point.y);
      pg.ellipse(symPoint.x, symPoint.y, 5);
    }

    function applySymmetryToLine(p1, p2) {
      let symP1 = createVector(width - p1.x, p1.y);
      let symP2 = createVector(width - p2.x, p2.y);
      pg.line(symP1.x, symP1.y, symP2.x, symP2.y);
    }

    function drawSymmetry() {
      image(pg, 0, 0, width, height);
    }

    function getCell(position) {
      let col = Math.floor(position.x / cellWidth);
      let row = Math.floor(position.y / cellHeight);
      return { row, col };
    }

    function moveToNewZone() {
      let newCol, newRow;
      do {
        newCol = Math.floor(random(gridCols));
        newRow = Math.floor(random(gridRows));
      } while (pointCountGrid[newRow][newCol] > 50);

      pos.x = newCol * cellWidth + cellWidth / 2;
      pos.y = newRow * cellHeight + cellHeight / 2;

      console.log(`Movido a nueva zona: fila ${newRow}, columna ${newCol}`);
    }

    function startGeneration() {
      resetParameters();
      isGenerating = true;

      const generationStart = millis();
      const duration = 18000;

      clearTimeout(generationTimer);
      generationTimer = setTimeout(() => {
        stopGeneration();
      }, duration);
    }

    function stopGeneration() {
      if (!isGenerating) return;
      isGenerating = false;

      console.log("Generación finalizada.");
    }

    function downloadTexture() {
      save(pg, 'Mancha_generada.png');
    }
  </script>
</body>
</html>
